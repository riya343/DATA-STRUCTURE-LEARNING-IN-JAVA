 ------------------------------------  PRINT DECREASING ---------------------------------
in this question , we need to print given imput in decreasing order.
  // here code for this 

  import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        PrintDecreasing(n);
    }
    public static void PrintDecreasing(int n) {
        if (n == 0) {
            return;
        }
        System.out.println(n);
        PrintDecreasing(n - 1);
    }
}

------------------------------------ PRINT INCREASIING ------------------------------------
  in this question , we need to print given imput in increasing order.
  // here code for this 

  import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        PrintDecreasing(n);
    }
    public static void PrintDecreasing(int n) {
        if (n == 0) {
            return;
        }
        PrintDecreasing(n - 1);
        System.out.println(n);
    }
}

------------------------------- PRINT DECREASING INCREASING ----------------------------------------
 in this question , we need to print given imput in decreasing and increasing order at same time.
  // here code for this 

  import java.util.Scanner;

public class main{
public static void main (String [] args){

    Scanner scn = new Scanner (System.in);
    int n = scn.nextInt();
    PrintDecreasingIncreasing(n);
}
public static void  PrintDecreasingIncreasing(int n){
    if (n == 0){
        return;
    }
    System.out.println(n);
    PrintDecreasingIncreasing(n-1);
    System.out.println(n);
}
}

//  TRICK TO REMEMBER
// ->  Print before recursion → decreasing
// ->  Print after recursion → increasing
// ->  Both side print → increasing + decreasing

------------------------------------- FACTORIAL ---------------------------------------
in this we need to print the factorial of the given input. 
// Here the code for the question 


import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
       Scanner scn = new Scanner(System.in);
       int n = scn.nextInt();
      int result =  factorial(n);
        System.out.println(result);
    }
    public static int factorial(int n){
        if ( n == 0 || n == 1){
            return 1;
        }
        int fact1 = factorial(n-1);
        int fact = fact1 * n;
        return fact;
    }
}

---------------------------------------- PRINT POWER ----------------------------------------------
in this we are solving the number and its power value like 2 pow 4.
// here the code 

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
       Scanner scn = new Scanner(System.in);
       int x = scn.nextInt();
       int n = scn.nextInt();
      int result =  power(x , n );
        System.out.println(result);
    }
    public static int power(int x, int n){
        if ( n == 0){
            return 1;
        }
        int xnm1 = power(x,n-1);
        int xn = x * xnm1;
        return xn;
    }
}

// TYPE 2 OF SOLVING POWER QUESTION BY DIFFERENT LOGIC OF LOG(n) COMPLEXCITY

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
       Scanner scn = new Scanner(System.in);
       int x = scn.nextInt();
       int n = scn.nextInt();
      int result =  power(x , n );
        System.out.println(result);
    }
    public static int power(int x, int n){
        if ( n == 0){
            return 1;
        }
        int xbn2 = power(x,n/2);
        int xn = xbn2 * xbn2;
    if (n%2!=0){
        xn= xn*x;
    }
        return xn;
    }
}

-------------------------------- TOWER OF HANOI -------------------------------------------
You are given n disks placed on a source rod.
Your task is to move all the disks to the destination rod using a helper rod, following these rules:
1. Only one disk can be moved at a time.
2. A larger disk cannot be placed on top of a smaller disk.
You must determine the sequence of moves required to transfer all the disks from the source rod to the destination rod.
// here the code 
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
       Scanner scn = new Scanner (System.in);
       int n = scn.nextInt();
        towerofHanoi(n,'A','B','C');
     
    }
    public static void towerofHanoi(int n,char src,char helper,char dest){
        if(n == 0){
            return;
        }
        towerofHanoi(n-1,src,dest,helper);
        System.out.println("move desk" + n + "from" + src +  "to" + dest);
        towerofHanoi(n-1,helper,src,dest);
    }
}

------------------------------------------  DISPLAY AND REVERSE OF AN ARRAY -------------------------------------
Dispaly and reverse of an array
// here the code

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[]arr = new int[n];
    
        for (int i = 0; i < arr.length; i++ ){
            arr[i] = scn.nextInt();
        }
        Displayarray(arr , 0);
        System.out.println();

        Reverseofarray(arr,0);
    }
    public static void Displayarray(int[] arr, int idx){
        if (idx == arr.length){
            return;
        }
        System.out.println( arr[idx] + " ");
        Displayarray( arr, idx+1);
    }
    public static void Reverseofarray( int[]arr, int idx){
        if (idx == arr.length){
            return;
        }
        Reverseofarray(arr, idx+1);
        System.out.println(arr[idx] + " ");
    }
}

---------------------------------------------- MAXIMUM ARRAY ------------------------------------------
print of maximum number from the array
// here the code

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[]arr = new int[n];

        for (int i = 0 ; i < arr.length ; i++){
            arr[i]= scn.nextInt();
        }
        int max = maxofarray(arr, 0);
        System.out.println(max);

        }
        public static int maxofarray( int[]arr, int idx){
         if ( idx == arr.length - 1){
              return  arr[idx];
         }
        int misa = maxofarray( arr,  idx+1);
        if (misa > arr[idx]){
            return misa;
        } else {
            return arr[idx];
        }
         }
    }

----------------------------------------- FIRST OCCURANCE --------------------------------------
we need to print the first occurance of an element in an given array
// here's the code

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[]arr = new int[n];
        
        for (int i = 0 ; i < arr.length ; i++){
            arr[i]= scn.nextInt();
        }
         int d = scn.nextInt();

       int ans =  Firstoccurance( arr, 0, d);
       System.out.println(ans);
     }
    public static int Firstoccurance( int[] arr, int idx , int d){
        if ( idx == arr.length){
            return -1;
        }
        if ( arr[idx] == d){ 
            return idx;
        }
        return Firstoccurance( arr, idx+1,d);
    }        
   }
----------------------------------------- LAST OCCURANCE -------------------------------------
we need to print the last occurance of an element in an given array
// here's the code

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[]arr = new int[n];
        
        for (int i = 0 ; i < arr.length ; i++){
            arr[i]= scn.nextInt();
        }
         int d = scn.nextInt();

       int ans =  lastoccurance( arr, 0, d);
       System.out.println(ans);
     }
    public static int lastoccurance( int[] arr, int idx , int d){
        if ( idx == arr.length){
            return -1;
        }
         int lisa = lastoccurance(arr, idx + 1, d);

        if ( lisa != -1){
            return lisa;

        }
        if ( arr[idx] == d){ 
            return idx;
        }
        return -1;
    }        
  }
--------------------------------------- ALL INDICES ----------------------------------------
we need to print the all indexes  in an given array
// here's the code

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int n = scn.nextInt();
        int[]arr = new int[n];
        
        for (int i = 0 ; i < arr.length ; i++){
            arr[i]= scn.nextInt();
        }
         int d = scn.nextInt();

      allindices( arr, 0, d);
     }
    public static void allindices( int[] arr, int idx , int d){
        if ( idx == arr.length){
            return ;
        }
        if ( arr[idx] == d){ 
            System.out.println(idx);
        }
         allindices( arr, idx+1, d);
    }        
}


--------------------------------------- TARGET SUM ----------------------------------------
we need to tell the possible ways of getting a sum from given numbers 

// here the code

import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {

        Scanner scn = new Scanner(System.in);

        int n = scn.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n; i++){
            arr[i] = scn.nextInt();
        }

        int tar = scn.nextInt();

        printTargetsum(arr, 0, "", 0, tar);
    }

    public static void printTargetsum(int[] arr, int idx, String set, int sos, int tar){

        if(idx == arr.length){
            if(sos == tar){
                System.out.println(set);
            }
            return;
        }

        // include
        printTargetsum(arr, idx + 1, set + arr[idx] + " ", sos + arr[idx], tar);

        // exclude
        printTargetsum(arr, idx + 1, set, sos, tar);
    }
}

---------------------------------- MAZE PATH WITH JUMPS --------------------------------

In this question, we need to print all possible paths from source to destination in a maze.
We are allowed to move in three directions:
Horizontal (h)
Vertical (v)
Diagonal (d)

Also, we can take jumps of variable length in any direction.
The task is to return all possible paths in the form of strings using recursion.

// here is the code for this problem

import java.util.ArrayList;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {

        Scanner scn = new Scanner(System.in);

        int dr = scn.nextInt();     // destination row
        int dc = scn.nextInt();     // destination column

        ArrayList<String> paths = getMazePaths(0, 0, dr - 1, dc - 1);

        System.out.println(paths);
    }

    public static ArrayList<String> getMazePaths(int sr, int sc, int dr, int dc) {

        // base case: when source reaches destination
        if (sr == dr && sc == dc) {
            ArrayList<String> bres = new ArrayList<>();
            bres.add("");
            return bres;
        }

        ArrayList<String> paths = new ArrayList<>();

        // horizontal moves
        for (int jump = 1; sc + jump <= dc; jump++) {
            ArrayList<String> hpaths = getMazePaths(sr, sc + jump, dr, dc);

            for (String path : hpaths) {
                paths.add("h" + jump + path);
            }
        }

        // vertical moves
        for (int jump = 1; sr + jump <= dr; jump++) {
            ArrayList<String> vpaths = getMazePaths(sr + jump, sc, dr, dc);

            for (String path : vpaths) {
                paths.add("v" + jump + path);
            }
        }

        // diagonal moves
        for (int jump = 1; sr + jump <= dr && sc + jump <= dc; jump++) {
            ArrayList<String> dpaths = getMazePaths(sr + jump, sc + jump, dr, dc);

            for (String path : dpaths) {
                paths.add("d" + jump + path);
            }
        }

        return paths;
    }
}

















